/* automatically generated by rust-bindgen 0.68.1 */

pub const ROARING_VERSION: &[u8; 6] = b"2.0.2\0";
pub const ROARING_VERSION_MAJOR: _bindgen_ty_1 = 2;
pub const ROARING_VERSION_MINOR: _bindgen_ty_1 = 0;
pub const ROARING_VERSION_REVISION: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Roaring arrays are array-based key-value pairs having containers as values\n and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_array_s {
    pub size: i32,
    pub allocation_size: i32,
    pub containers: *mut *mut ::std::os::raw::c_void,
    pub keys: *mut u16,
    pub typecodes: *mut u8,
    pub flags: u8,
}
#[doc = " Roaring arrays are array-based key-value pairs having containers as values\n and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
pub type roaring_array_t = roaring_array_s;
pub type roaring_iterator = ::std::option::Option<
    unsafe extern "C" fn(value: u32, param: *mut ::std::os::raw::c_void) -> bool,
>;
pub type roaring_iterator64 = ::std::option::Option<
    unsafe extern "C" fn(value: u64, param: *mut ::std::os::raw::c_void) -> bool,
>;
#[doc = "  (For advanced users.)\n The roaring_statistics_t can be used to collect detailed statistics about\n the composition of a roaring bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_statistics_s {
    pub n_containers: u32,
    pub n_array_containers: u32,
    pub n_run_containers: u32,
    pub n_bitset_containers: u32,
    pub n_values_array_containers: u32,
    pub n_values_run_containers: u32,
    pub n_values_bitset_containers: u32,
    pub n_bytes_array_containers: u32,
    pub n_bytes_run_containers: u32,
    pub n_bytes_bitset_containers: u32,
    pub max_value: u32,
    pub min_value: u32,
    pub sum_value: u64,
    pub cardinality: u64,
}
#[doc = "  (For advanced users.)\n The roaring_statistics_t can be used to collect detailed statistics about\n the composition of a roaring bitmap."]
pub type roaring_statistics_t = roaring_statistics_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset_s {
    pub array: *mut u64,
    pub arraysize: usize,
    pub capacity: usize,
}
pub type bitset_t = bitset_s;
extern "C" {
    pub fn bitset_create() -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_create_with_capacity(size: usize) -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_free(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_clear(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_fill(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_copy(bitset: *const bitset_t) -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_resize(bitset: *mut bitset_t, newarraysize: usize, padwithzeroes: bool) -> bool;
}
extern "C" {
    pub fn bitset_size_in_bytes(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_size_in_bits(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_size_in_words(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_grow(bitset: *mut bitset_t, newarraysize: usize) -> bool;
}
extern "C" {
    pub fn bitset_trim(bitset: *mut bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_shift_left(bitset: *mut bitset_t, s: usize);
}
extern "C" {
    pub fn bitset_shift_right(bitset: *mut bitset_t, s: usize);
}
extern "C" {
    pub fn bitset_set(bitset: *mut bitset_t, i: usize);
}
extern "C" {
    pub fn bitset_set_to_value(bitset: *mut bitset_t, i: usize, flag: bool);
}
extern "C" {
    pub fn bitset_get(bitset: *const bitset_t, i: usize) -> bool;
}
extern "C" {
    pub fn bitset_count(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_minimum(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_maximum(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_union(b1: *mut bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_union_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_intersection(b1: *mut bitset_t, b2: *const bitset_t);
}
extern "C" {
    pub fn bitset_intersection_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitsets_disjoint(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitsets_intersect(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_contains_all(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_inplace_difference(b1: *mut bitset_t, b2: *const bitset_t);
}
extern "C" {
    pub fn bitset_difference_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_symmetric_difference(b1: *mut bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_symmetric_difference_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_next_set_bit(bitset: *const bitset_t, i: *mut usize) -> bool;
}
extern "C" {
    pub fn bitset_next_set_bits(
        bitset: *const bitset_t,
        buffer: *mut usize,
        capacity: usize,
        startfrom: *mut usize,
    ) -> usize;
}
pub type bitset_iterator = ::std::option::Option<
    unsafe extern "C" fn(value: usize, param: *mut ::std::os::raw::c_void) -> bool,
>;
extern "C" {
    pub fn bitset_for_each(
        b: *const bitset_t,
        iterator: bitset_iterator,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn bitset_print(b: *const bitset_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_bitmap_s {
    pub high_low_container: roaring_array_t,
}
pub type roaring_bitmap_t = roaring_bitmap_s;
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty).\n Returns NULL if the allocation fails.\n Capacity is a performance hint for how many \"containers\" the data will need.\n Client is responsible for calling `roaring_bitmap_free()`."]
    pub fn roaring_bitmap_create_with_capacity(cap: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty).\n Returns NULL if the allocation fails.\n Client is responsible for calling `roaring_bitmap_free()`."]
    pub fn roaring_bitmap_create() -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Initialize a roaring bitmap structure in memory controlled by client.\n Capacity is a performance hint for how many \"containers\" the data will need.\n Can return false if auxiliary allocations fail when capacity greater than 0."]
    pub fn roaring_bitmap_init_with_capacity(r: *mut roaring_bitmap_t, cap: u32) -> bool;
}
extern "C" {
    #[doc = " Initialize a roaring bitmap structure in memory controlled by client.\n The bitmap will be in a \"clear\" state, with no auxiliary allocations.\n Since this performs no allocations, the function will not fail."]
    pub fn roaring_bitmap_init_cleared(r: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Add all the values between min (included) and max (excluded) that are at a\n distance k*step from min."]
    pub fn roaring_bitmap_from_range(min: u64, max: u64, step: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Creates a new bitmap from a pointer of uint32_t integers"]
    pub fn roaring_bitmap_of_ptr(n_args: usize, vals: *const u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    pub fn roaring_bitmap_get_copy_on_write(r: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    pub fn roaring_bitmap_set_copy_on_write(r: *mut roaring_bitmap_t, cow: bool);
}
extern "C" {
    pub fn roaring_bitmap_add_offset(
        bm: *const roaring_bitmap_t,
        offset: i64,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Describe the inner structure of the bitmap."]
    pub fn roaring_bitmap_printf_describe(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Creates a new bitmap from a list of uint32_t integers"]
    pub fn roaring_bitmap_of(n: usize, ...) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap (this does memory allocation).\n The caller is responsible for memory management."]
    pub fn roaring_bitmap_copy(r: *const roaring_bitmap_t) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap from src to dest. It is assumed that the pointer dest\n is to an already allocated bitmap. The content of the dest bitmap is\n freed/deleted.\n\n It might be preferable and simpler to call roaring_bitmap_copy except\n that roaring_bitmap_overwrite can save on memory allocations.\n\n Returns true if successful, or false if there was an error. On failure,\n the dest bitmap is left in a valid, empty state (even if it was not empty before)."]
    pub fn roaring_bitmap_overwrite(
        dest: *mut roaring_bitmap_t,
        src: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Print the content of the bitmap."]
    pub fn roaring_bitmap_printf(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the intersection between two bitmaps and returns new bitmap. The\n caller is responsible for memory management.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmap.\n You may also rely on roaring_bitmap_and_inplace to avoid creating\n many temporary bitmaps."]
    pub fn roaring_bitmap_and(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the intersection between two bitmaps."]
    pub fn roaring_bitmap_and_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Check whether two bitmaps intersect."]
    pub fn roaring_bitmap_intersect(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a bitmap and a closed range intersect."]
    pub fn roaring_bitmap_intersect_with_range(bm: *const roaring_bitmap_t, x: u64, y: u64)
        -> bool;
}
extern "C" {
    #[doc = " Computes the Jaccard index between two bitmaps. (Also known as the Tanimoto\n distance, or the Jaccard similarity coefficient)\n\n The Jaccard index is undefined if both bitmaps are empty."]
    pub fn roaring_bitmap_jaccard_index(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> f64;
}
extern "C" {
    #[doc = " Computes the size of the union between two bitmaps."]
    pub fn roaring_bitmap_or_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the difference (andnot) between two bitmaps."]
    pub fn roaring_bitmap_andnot_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the symmetric difference (xor) between two bitmaps."]
    pub fn roaring_bitmap_xor_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_and()`, modifies r1\n r1 == r2 is allowed.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmap."]
    pub fn roaring_bitmap_and_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the union between two bitmaps and returns new bitmap. The caller is\n responsible for memory management."]
    pub fn roaring_bitmap_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_or(), modifies r1.\n TODO: decide whether r1 == r2 ok"]
    pub fn roaring_bitmap_or_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps.\n Caller is responsible for freeing the result.\n See also `roaring_bitmap_or_many_heap()`"]
    pub fn roaring_bitmap_or_many(
        number: usize,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps using a heap. This can sometimes be\n faster than `roaring_bitmap_or_many() which uses a naive algorithm.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_or_many_heap(
        number: u32,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the symmetric difference (xor) between two bitmaps\n and returns new bitmap. The caller is responsible for memory management."]
    pub fn roaring_bitmap_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_xor, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the xor of 'number' bitmaps.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_xor_many(
        number: usize,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the difference (andnot) between two bitmaps and returns new bitmap.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_andnot(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_andnot, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_andnot_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Frees the memory."]
    pub fn roaring_bitmap_free(r: *const roaring_bitmap_t);
}
#[doc = " A bit of context usable with `roaring_bitmap_*_bulk()` functions\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap\n (unless re-initialized to zero), and any modification to a bitmap\n (other than modifications performed with `_bulk()` functions with the context\n passed) will invalidate any contexts associated with that bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_bulk_context_s {
    pub container: *mut ::std::os::raw::c_void,
    pub idx: ::std::os::raw::c_int,
    pub key: u16,
    pub typecode: u8,
}
#[doc = " A bit of context usable with `roaring_bitmap_*_bulk()` functions\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap\n (unless re-initialized to zero), and any modification to a bitmap\n (other than modifications performed with `_bulk()` functions with the context\n passed) will invalidate any contexts associated with that bitmap."]
pub type roaring_bulk_context_t = roaring_bulk_context_s;
extern "C" {
    #[doc = " Add an item, using context from a previous insert for speed optimization.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same \"key\" (high 16 bits of the value) consecutively."]
    pub fn roaring_bitmap_add_bulk(
        r: *mut roaring_bitmap_t,
        context: *mut roaring_bulk_context_t,
        val: u32,
    );
}
extern "C" {
    #[doc = " Add value n_args from pointer vals, faster than repeatedly calling\n `roaring_bitmap_add()`\n\n In order to exploit this optimization, the caller should attempt to keep\n values with the same \"key\" (high 16 bits of the value) as consecutive\n elements in `vals`"]
    pub fn roaring_bitmap_add_many(r: *mut roaring_bitmap_t, n_args: usize, vals: *const u32);
}
extern "C" {
    #[doc = " Add value x"]
    pub fn roaring_bitmap_add(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Add value x\n Returns true if a new value was added, false if the value already existed."]
    pub fn roaring_bitmap_add_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Add all values in range [min, max]"]
    pub fn roaring_bitmap_add_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Add all values in range [min, max)"]
    pub fn roaring_bitmap_add_range(r: *mut roaring_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Remove value x"]
    pub fn roaring_bitmap_remove(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Remove all values in range [min, max]"]
    pub fn roaring_bitmap_remove_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Remove all values in range [min, max)"]
    pub fn roaring_bitmap_remove_range(r: *mut roaring_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Remove multiple values"]
    pub fn roaring_bitmap_remove_many(r: *mut roaring_bitmap_t, n_args: usize, vals: *const u32);
}
extern "C" {
    #[doc = " Remove value x\n Returns true if a new value was removed, false if the value was not existing."]
    pub fn roaring_bitmap_remove_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Check if value is present"]
    pub fn roaring_bitmap_contains(r: *const roaring_bitmap_t, val: u32) -> bool;
}
extern "C" {
    #[doc = " Check whether a range of values from range_start (included)\n to range_end (excluded) is present"]
    pub fn roaring_bitmap_contains_range(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if an items is present, using context from a previous insert or search\n for speed optimization.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same \"key\" (high 16 bits of the value) consecutively."]
    pub fn roaring_bitmap_contains_bulk(
        r: *const roaring_bitmap_t,
        context: *mut roaring_bulk_context_t,
        val: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the cardinality of the bitmap (number of elements)."]
    pub fn roaring_bitmap_get_cardinality(r: *const roaring_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [range_start, range_end)."]
    pub fn roaring_bitmap_range_cardinality(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns true if the bitmap is empty (cardinality is zero)."]
    pub fn roaring_bitmap_is_empty(r: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Empties the bitmap.  It will have no auxiliary allocations (so if the bitmap\n was initialized in client memory via roaring_bitmap_init(), then a call to\n roaring_bitmap_clear() would be enough to \"free\" it)"]
    pub fn roaring_bitmap_clear(r: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Convert the bitmap to a sorted array, output in `ans`.\n\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n\n     ans = malloc(roaring_bitmap_get_cardinality(bitmap) * sizeof(uint32_t));"]
    pub fn roaring_bitmap_to_uint32_array(r: *const roaring_bitmap_t, ans: *mut u32);
}
extern "C" {
    #[doc = " Store the bitmap to a bitset. This can be useful for people\n who need the performance and simplicity of a standard bitset.\n We assume that the input bitset is originally empty (does not\n have any set bit).\n\n   bitset_t * out = bitset_create();\n   // if the bitset has content in it, call \"bitset_clear(out)\"\n   bool success = roaring_bitmap_to_bitset(mybitmap, out);\n   // on failure, success will be false.\n   // You can then query the bitset:\n   bool is_present = bitset_get(out,  10011 );\n   // you must free the memory:\n   bitset_free(out);\n"]
    pub fn roaring_bitmap_to_bitset(r: *const roaring_bitmap_t, bitset: *mut bitset_t) -> bool;
}
extern "C" {
    #[doc = " Convert the bitmap to a sorted array from `offset` by `limit`, output in `ans`.\n\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n\n     ans = malloc(roaring_bitmap_get_cardinality(limit) * sizeof(uint32_t));\n\n Return false in case of failure (e.g., insufficient memory)"]
    pub fn roaring_bitmap_range_uint32_array(
        r: *const roaring_bitmap_t,
        offset: usize,
        limit: usize,
        ans: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove run-length encoding even when it is more space efficient.\n Return whether a change was applied."]
    pub fn roaring_bitmap_remove_run_compression(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Convert array and bitmap containers to run containers when it is more\n efficient; also convert from run containers when more space efficient.\n\n Returns true if the result has at least one run container.\n Additional savings might be possible by calling `shrinkToFit()`."]
    pub fn roaring_bitmap_run_optimize(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " If needed, reallocate memory to shrink the memory usage.\n Returns the number of bytes saved."]
    pub fn roaring_bitmap_shrink_to_fit(r: *mut roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Write the bitmap to an output pointer, this output buffer should refer to\n at least `roaring_bitmap_size_in_bytes(r)` allocated bytes.\n\n See `roaring_bitmap_portable_serialize()` if you want a format that's\n compatible with Java and Go implementations.  This format can sometimes be\n more space efficient than the portable form, e.g. when the data is sparse.\n\n Returns how many bytes written, should be `roaring_bitmap_size_in_bytes(r)`.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Use with `roaring_bitmap_serialize()`.\n\n (See `roaring_bitmap_portable_deserialize()` if you want a format that's\n compatible with Java and Go implementations).\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_deserialize(buf: *const ::std::os::raw::c_void) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Use with `roaring_bitmap_serialize()`.\n\n (See `roaring_bitmap_portable_deserialize_safe()` if you want a format that's\n compatible with Java and Go implementations).\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems.\n\n The difference with `roaring_bitmap_deserialize()` is that this function checks that the input buffer\n is a valid bitmap.  If the buffer is too small, NULL is returned."]
    pub fn roaring_bitmap_deserialize_safe(
        buf: *const ::std::os::raw::c_void,
        maxbytes: usize,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap (NOT compatible\n with Java and Go versions)"]
    pub fn roaring_bitmap_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer.\n In case of failure, NULL is returned.\n\n This function is unsafe in the sense that if there is no valid serialized\n bitmap at the pointer, then many bytes could be read, possibly causing a\n buffer overflow.  See also roaring_bitmap_portable_deserialize_safe().\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize(
        buf: *const ::std::os::raw::c_char,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer safely (reading up to maxbytes).\n In case of failure, NULL is returned.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n The function itself is safe in the sense that it will not cause buffer overflows.\n However, for correct operations, it is assumed that the bitmap read was once\n serialized from a valid bitmap (i.e., it follows the format specification).\n If you provided an incorrect input (garbage), then the bitmap read may not be in\n a valid state and following operations may not lead to sensible results.\n In particular, the serialized array containers need to be in sorted order, and the\n run containers should be in sorted non-overlapping order. This is is guaranteed to\n happen when serializing an existing bitmap, but not for random inputs.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize_safe(
        buf: *const ::std::os::raw::c_char,
        maxbytes: usize,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer.\n In case of failure, NULL is returned.\n\n Bitmap returned by this function can be used in all readonly contexts.\n Bitmap must be freed as usual, by calling roaring_bitmap_free().\n Underlying buffer must not be freed or modified while it backs any bitmaps.\n\n The function is unsafe in the following ways:\n 1) It may execute unaligned memory accesses.\n 2) A buffer overflow may occur if buf does not point to a valid serialized\n    bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize_frozen(
        buf: *const ::std::os::raw::c_char,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Check how many bytes would be read (up to maxbytes) at this pointer if there\n is a bitmap, returns zero if there is no valid bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_deserialize_size(
        buf: *const ::std::os::raw::c_char,
        maxbytes: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Write a bitmap to a char buffer.  The output buffer should refer to at least\n `roaring_bitmap_portable_size_in_bytes(r)` bytes of allocated memory.\n\n Returns how many bytes were written which should match\n `roaring_bitmap_portable_size_in_bytes(r)`.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns number of bytes required to serialize bitmap using frozen format."]
    pub fn roaring_bitmap_frozen_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Serializes bitmap using frozen format.\n Buffer size must be at least roaring_bitmap_frozen_size_in_bytes().\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_frozen_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Creates constant bitmap that is a view of a given buffer.\n Buffer data should have been written by `roaring_bitmap_frozen_serialize()`\n Its beginning must also be aligned by 32 bytes.\n Length must be equal exactly to `roaring_bitmap_frozen_size_in_bytes()`.\n In case of failure, NULL is returned.\n\n Bitmap returned by this function can be used in all readonly contexts.\n Bitmap must be freed as usual, by calling roaring_bitmap_free().\n Underlying buffer must not be freed or modified while it backs any bitmaps.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a mainframe IBM s390x),\n the data format is going to be big-endian and not compatible with little-endian systems."]
    pub fn roaring_bitmap_frozen_view(
        buf: *const ::std::os::raw::c_char,
        length: usize,
    ) -> *const roaring_bitmap_t;
}
extern "C" {
    #[doc = " Iterate over the bitmap elements. The function iterator is called once for\n all the values with ptr (can be NULL) as the second parameter of each call.\n\n `roaring_iterator` is simply a pointer to a function that returns bool\n (true means that the iteration should continue while false means that it\n should stop), and takes (uint32_t,void*) as inputs.\n\n Returns true if the roaring_iterator returned true throughout (so that all\n data points were necessarily visited).\n\n Iteration is ordered: from the smallest to the largest elements."]
    pub fn roaring_iterate(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn roaring_iterate64(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator64,
        high_bits: u64,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the two bitmaps contain the same elements."]
    pub fn roaring_bitmap_equals(r1: *const roaring_bitmap_t, r2: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2."]
    pub fn roaring_bitmap_is_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2, and r2 is strictly\n greater than r1."]
    pub fn roaring_bitmap_is_strict_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Computes the union between two bitmaps and returns new bitmap. The caller is\n responsible for memory management.\n\n The lazy version defers some computations such as the maintenance of the\n cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`\n after executing \"lazy\" computations.\n\n It is safe to repeatedly call roaring_bitmap_lazy_or_inplace on the result.\n\n `bitsetconversion` is a flag which determines whether container-container\n operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Inplace version of roaring_bitmap_lazy_or, modifies r1.\n\n `bitsetconversion` is a flag which determines whether container-container\n operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or_inplace(
        r1: *mut roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    );
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Execute maintenance on a bitmap created from `roaring_bitmap_lazy_or()`\n or modified with `roaring_bitmap_lazy_or_inplace()`."]
    pub fn roaring_bitmap_repair_after_lazy(r1: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the symmetric difference between two bitmaps and returns new bitmap.\n The caller is responsible for memory management.\n\n The lazy version defers some computations such as the maintenance of the\n cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`\n after executing \"lazy\" computations.\n\n It is safe to repeatedly call `roaring_bitmap_lazy_xor_inplace()` on\n the result."]
    pub fn roaring_bitmap_lazy_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Inplace version of roaring_bitmap_lazy_xor, modifies r1. r1 != r2"]
    pub fn roaring_bitmap_lazy_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [range_start, range_end).\n The number of negated values is range_end - range_start.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip(
        r1: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " compute (in place) the negation of the roaring bitmap within a specified\n interval: [range_start, range_end). The number of negated values is\n range_end - range_start.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip_inplace(r1: *mut roaring_bitmap_t, range_start: u64, range_end: u64);
}
extern "C" {
    #[doc = " Selects the element at index 'rank' where the smallest element is at index 0.\n If the size of the roaring bitmap is strictly greater than rank, then this\n function returns true and sets element to the element of given rank.\n Otherwise, it returns false."]
    pub fn roaring_bitmap_select(r: *const roaring_bitmap_t, rank: u32, element: *mut u32) -> bool;
}
extern "C" {
    #[doc = " roaring_bitmap_rank returns the number of integers that are smaller or equal\n to x. Thus if x is the first element, this function will return 1. If\n x is smaller than the smallest element, this function will return 0.\n\n The indexing convention differs between roaring_bitmap_select and\n roaring_bitmap_rank: roaring_bitmap_select refers to the smallest value\n as having index 0, whereas roaring_bitmap_rank returns 1 when ranking\n the smallest value."]
    pub fn roaring_bitmap_rank(r: *const roaring_bitmap_t, x: u32) -> u64;
}
extern "C" {
    #[doc = " Returns the index of x in the given roaring bitmap.\n If the roaring bitmap doesn't contain x , this function will return -1.\n The difference with rank function is that this function will return -1 when x\n is not the element of roaring bitmap, but the rank function will return a\n non-negative number."]
    pub fn roaring_bitmap_get_index(r: *const roaring_bitmap_t, x: u32) -> i64;
}
extern "C" {
    #[doc = " Returns the smallest value in the set, or UINT32_MAX if the set is empty."]
    pub fn roaring_bitmap_minimum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " Returns the greatest value in the set, or 0 if the set is empty."]
    pub fn roaring_bitmap_maximum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " (For advanced users.)\n\n Collect statistics about the bitmap, see roaring_types.h for\n a description of roaring_statistics_t"]
    pub fn roaring_bitmap_statistics(r: *const roaring_bitmap_t, stat: *mut roaring_statistics_t);
}
extern "C" {
    #[doc = " Perform internal consistency checks. Returns true if the bitmap is consistent.\n\n Note that some operations intentionally leave bitmaps in an inconsistent state temporarily,\n for example, `roaring_bitmap_lazy_*` functions, until `roaring_bitmap_repair_after_lazy` is called.\n\n If reason is non-null, it will be set to a string describing the first inconsistency found if any."]
    pub fn roaring_bitmap_internal_validate(
        r: *const roaring_bitmap_t,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
#[doc = " What follows is code use to iterate through values in a roaring bitmap\n\nroaring_bitmap_t *r =...\nroaring_uint32_iterator_t i;\nroaring_create_iterator(r, &i);\nwhile(i.has_value) {\nprintf(\"value = %d\\n\", i.current_value);\nroaring_advance_uint32_iterator(&i);\n}\n\nObviously, if you modify the underlying bitmap, the iterator\nbecomes invalid. So don't."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_uint32_iterator_s {
    pub parent: *const roaring_bitmap_t,
    pub container_index: i32,
    pub in_container_index: i32,
    pub run_index: i32,
    pub current_value: u32,
    pub has_value: bool,
    pub container: *const ::std::os::raw::c_void,
    pub typecode: u8,
    pub highbits: u32,
}
#[doc = " What follows is code use to iterate through values in a roaring bitmap\n\nroaring_bitmap_t *r =...\nroaring_uint32_iterator_t i;\nroaring_create_iterator(r, &i);\nwhile(i.has_value) {\nprintf(\"value = %d\\n\", i.current_value);\nroaring_advance_uint32_iterator(&i);\n}\n\nObviously, if you modify the underlying bitmap, the iterator\nbecomes invalid. So don't."]
pub type roaring_uint32_iterator_t = roaring_uint32_iterator_s;
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the\n values. If there is a  value, then this iterator points to the first value\n and `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_init_iterator(r: *const roaring_bitmap_t, newit: *mut roaring_uint32_iterator_t);
}
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the\n values. If there is a value, then this iterator points to the last value\n and `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_init_iterator_last(
        r: *const roaring_bitmap_t,
        newit: *mut roaring_uint32_iterator_t,
    );
}
extern "C" {
    #[doc = " Create an iterator object that can be used to iterate through the values.\n Caller is responsible for calling `roaring_free_iterator()`.\n\n The iterator is initialized (this function calls `roaring_init_iterator()`)\n If there is a value, then this iterator points to the first value and\n `it->has_value` is true.  The value is in `it->current_value`."]
    pub fn roaring_create_iterator(r: *const roaring_bitmap_t) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Advance the iterator. If there is a new value, then `it->has_value` is true.\n The new value is in `it->current_value`. Values are traversed in increasing\n orders. For convenience, returns `it->has_value`."]
    pub fn roaring_advance_uint32_iterator(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Decrement the iterator. If there's a new value, then `it->has_value` is true.\n The new value is in `it->current_value`. Values are traversed in decreasing\n order. For convenience, returns `it->has_value`."]
    pub fn roaring_previous_uint32_iterator(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Move the iterator to the first value >= `val`. If there is a such a value,\n then `it->has_value` is true. The new value is in `it->current_value`.\n For convenience, returns `it->has_value`."]
    pub fn roaring_move_uint32_iterator_equalorlarger(
        it: *mut roaring_uint32_iterator_t,
        val: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a copy of an iterator.\n Caller must free it."]
    pub fn roaring_copy_uint32_iterator(
        it: *const roaring_uint32_iterator_t,
    ) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Free memory following `roaring_create_iterator()`"]
    pub fn roaring_free_uint32_iterator(it: *mut roaring_uint32_iterator_t);
}
extern "C" {
    pub fn roaring_read_uint32_iterator(
        it: *mut roaring_uint32_iterator_t,
        buf: *mut u32,
        count: u32,
    ) -> u32;
}
pub type roaring_malloc_p =
    ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>;
pub type roaring_realloc_p = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type roaring_calloc_p = ::std::option::Option<
    unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void,
>;
pub type roaring_free_p =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type roaring_aligned_malloc_p = ::std::option::Option<
    unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void,
>;
pub type roaring_aligned_free_p =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_memory_s {
    pub malloc: roaring_malloc_p,
    pub realloc: roaring_realloc_p,
    pub calloc: roaring_calloc_p,
    pub free: roaring_free_p,
    pub aligned_malloc: roaring_aligned_malloc_p,
    pub aligned_free: roaring_aligned_free_p,
}
pub type roaring_memory_t = roaring_memory_s;
extern "C" {
    pub fn roaring_init_memory_hook(memory_hook: roaring_memory_t);
}
extern "C" {
    pub fn roaring_malloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn roaring_realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn roaring_calloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn roaring_free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn roaring_aligned_malloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn roaring_aligned_free(arg1: *mut ::std::os::raw::c_void);
}
