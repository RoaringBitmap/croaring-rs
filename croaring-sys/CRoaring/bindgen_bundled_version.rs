/* automatically generated by rust-bindgen 0.71.1 */

pub const ROARING_VERSION: &[u8; 6] = b"4.2.3\0";
pub const ROARING_VERSION_MAJOR: _bindgen_ty_1 = 4;
pub const ROARING_VERSION_MINOR: _bindgen_ty_1 = 2;
pub const ROARING_VERSION_REVISION: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
extern "C" {
    #[doc = " result might be undefined when input_num is zero"]
    pub fn roaring_trailing_zeroes(input_num: ::core::ffi::c_ulonglong) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " result might be undefined when input_num is zero"]
    pub fn roaring_leading_zeroes(input_num: ::core::ffi::c_ulonglong) -> ::core::ffi::c_int;
}
#[doc = " Roaring arrays are array-based key-value pairs having containers as values\n and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_array_s {
    pub size: i32,
    pub allocation_size: i32,
    pub containers: *mut *mut ::core::ffi::c_void,
    pub keys: *mut u16,
    pub typecodes: *mut u8,
    pub flags: u8,
}
#[doc = " Roaring arrays are array-based key-value pairs having containers as values\n and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
pub type roaring_array_t = roaring_array_s;
pub type roaring_iterator = ::core::option::Option<
    unsafe extern "C" fn(value: u32, param: *mut ::core::ffi::c_void) -> bool,
>;
pub type roaring_iterator64 = ::core::option::Option<
    unsafe extern "C" fn(value: u64, param: *mut ::core::ffi::c_void) -> bool,
>;
#[doc = "  (For advanced users.)\n The roaring_statistics_t can be used to collect detailed statistics about\n the composition of a roaring bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_statistics_s {
    pub n_containers: u32,
    pub n_array_containers: u32,
    pub n_run_containers: u32,
    pub n_bitset_containers: u32,
    pub n_values_array_containers: u32,
    pub n_values_run_containers: u32,
    pub n_values_bitset_containers: u32,
    pub n_bytes_array_containers: u32,
    pub n_bytes_run_containers: u32,
    pub n_bytes_bitset_containers: u32,
    pub max_value: u32,
    pub min_value: u32,
    pub sum_value: u64,
    pub cardinality: u64,
}
#[doc = "  (For advanced users.)\n The roaring_statistics_t can be used to collect detailed statistics about\n the composition of a roaring bitmap."]
pub type roaring_statistics_t = roaring_statistics_s;
#[doc = "  (For advanced users.)\n The roaring64_statistics_t can be used to collect detailed statistics about\n the composition of a roaring64 bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring64_statistics_s {
    pub n_containers: u64,
    pub n_array_containers: u64,
    pub n_run_containers: u64,
    pub n_bitset_containers: u64,
    pub n_values_array_containers: u64,
    pub n_values_run_containers: u64,
    pub n_values_bitset_containers: u64,
    pub n_bytes_array_containers: u64,
    pub n_bytes_run_containers: u64,
    pub n_bytes_bitset_containers: u64,
    pub max_value: u64,
    pub min_value: u64,
    pub cardinality: u64,
}
#[doc = "  (For advanced users.)\n The roaring64_statistics_t can be used to collect detailed statistics about\n the composition of a roaring64 bitmap."]
pub type roaring64_statistics_t = roaring64_statistics_s;
#[doc = " Roaring-internal type used to iterate within a roaring container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_container_iterator_s {
    pub index: i32,
}
#[doc = " Roaring-internal type used to iterate within a roaring container."]
pub type roaring_container_iterator_t = roaring_container_iterator_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset_s {
    pub array: *mut u64,
    pub arraysize: usize,
    pub capacity: usize,
}
pub type bitset_t = bitset_s;
extern "C" {
    pub fn bitset_create() -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_create_with_capacity(size: usize) -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_free(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_clear(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_fill(bitset: *mut bitset_t);
}
extern "C" {
    pub fn bitset_copy(bitset: *const bitset_t) -> *mut bitset_t;
}
extern "C" {
    pub fn bitset_resize(bitset: *mut bitset_t, newarraysize: usize, padwithzeroes: bool) -> bool;
}
extern "C" {
    pub fn bitset_size_in_bytes(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_size_in_bits(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_size_in_words(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_grow(bitset: *mut bitset_t, newarraysize: usize) -> bool;
}
extern "C" {
    pub fn bitset_trim(bitset: *mut bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_shift_left(bitset: *mut bitset_t, s: usize);
}
extern "C" {
    pub fn bitset_shift_right(bitset: *mut bitset_t, s: usize);
}
extern "C" {
    pub fn bitset_set(bitset: *mut bitset_t, i: usize);
}
extern "C" {
    pub fn bitset_set_to_value(bitset: *mut bitset_t, i: usize, flag: bool);
}
extern "C" {
    pub fn bitset_get(bitset: *const bitset_t, i: usize) -> bool;
}
extern "C" {
    pub fn bitset_count(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_empty(bitset: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_minimum(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_maximum(bitset: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_union(b1: *mut bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_union_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_intersection(b1: *mut bitset_t, b2: *const bitset_t);
}
extern "C" {
    pub fn bitset_intersection_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitsets_disjoint(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitsets_intersect(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_contains_all(b1: *const bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_inplace_difference(b1: *mut bitset_t, b2: *const bitset_t);
}
extern "C" {
    pub fn bitset_difference_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_inplace_symmetric_difference(b1: *mut bitset_t, b2: *const bitset_t) -> bool;
}
extern "C" {
    pub fn bitset_symmetric_difference_count(b1: *const bitset_t, b2: *const bitset_t) -> usize;
}
extern "C" {
    pub fn bitset_next_set_bit(bitset: *const bitset_t, i: *mut usize) -> bool;
}
extern "C" {
    pub fn bitset_next_set_bits(
        bitset: *const bitset_t,
        buffer: *mut usize,
        capacity: usize,
        startfrom: *mut usize,
    ) -> usize;
}
pub type bitset_iterator = ::core::option::Option<
    unsafe extern "C" fn(value: usize, param: *mut ::core::ffi::c_void) -> bool,
>;
extern "C" {
    pub fn bitset_for_each(
        b: *const bitset_t,
        iterator: bitset_iterator,
        ptr: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn bitset_print(b: *const bitset_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_bitmap_s {
    pub high_low_container: roaring_array_t,
}
pub type roaring_bitmap_t = roaring_bitmap_s;
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty).\n Returns NULL if the allocation fails.\n Capacity is a performance hint for how many \"containers\" the data will need.\n Client is responsible for calling `roaring_bitmap_free()`."]
    pub fn roaring_bitmap_create_with_capacity(cap: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty).\n Returns NULL if the allocation fails.\n Client is responsible for calling `roaring_bitmap_free()`."]
    pub fn roaring_bitmap_create() -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Initialize a roaring bitmap structure in memory controlled by client.\n Capacity is a performance hint for how many \"containers\" the data will need.\n Can return false if auxiliary allocations fail when capacity greater than 0."]
    pub fn roaring_bitmap_init_with_capacity(r: *mut roaring_bitmap_t, cap: u32) -> bool;
}
extern "C" {
    #[doc = " Initialize a roaring bitmap structure in memory controlled by client.\n The bitmap will be in a \"clear\" state, with no auxiliary allocations.\n Since this performs no allocations, the function will not fail."]
    pub fn roaring_bitmap_init_cleared(r: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Add all the values between min (included) and max (excluded) that are at a\n distance k*step from min."]
    pub fn roaring_bitmap_from_range(min: u64, max: u64, step: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Creates a new bitmap from a pointer of uint32_t integers"]
    pub fn roaring_bitmap_of_ptr(n_args: usize, vals: *const u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    pub fn roaring_bitmap_get_copy_on_write(r: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    pub fn roaring_bitmap_set_copy_on_write(r: *mut roaring_bitmap_t, cow: bool);
}
extern "C" {
    pub fn roaring_bitmap_add_offset(
        bm: *const roaring_bitmap_t,
        offset: i64,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Describe the inner structure of the bitmap."]
    pub fn roaring_bitmap_printf_describe(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Creates a new bitmap from a list of uint32_t integers\n\n This function is deprecated, use `roaring_bitmap_from` instead, which\n doesn't require the number of elements to be passed in.\n\n @see roaring_bitmap_from"]
    pub fn roaring_bitmap_of(n: usize, ...) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap (this does memory allocation).\n The caller is responsible for memory management."]
    pub fn roaring_bitmap_copy(r: *const roaring_bitmap_t) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap from src to dest. It is assumed that the pointer dest\n is to an already allocated bitmap. The content of the dest bitmap is\n freed/deleted.\n\n It might be preferable and simpler to call roaring_bitmap_copy except\n that roaring_bitmap_overwrite can save on memory allocations.\n\n Returns true if successful, or false if there was an error. On failure,\n the dest bitmap is left in a valid, empty state (even if it was not empty\n before)."]
    pub fn roaring_bitmap_overwrite(
        dest: *mut roaring_bitmap_t,
        src: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Print the content of the bitmap."]
    pub fn roaring_bitmap_printf(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the intersection between two bitmaps and returns new bitmap. The\n caller is responsible for memory management.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmap.\n You may also rely on roaring_bitmap_and_inplace to avoid creating\n many temporary bitmaps."]
    pub fn roaring_bitmap_and(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the intersection between two bitmaps."]
    pub fn roaring_bitmap_and_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Check whether two bitmaps intersect."]
    pub fn roaring_bitmap_intersect(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a bitmap and an open range intersect."]
    pub fn roaring_bitmap_intersect_with_range(bm: *const roaring_bitmap_t, x: u64, y: u64)
        -> bool;
}
extern "C" {
    #[doc = " Computes the Jaccard index between two bitmaps. (Also known as the Tanimoto\n distance, or the Jaccard similarity coefficient)\n\n The Jaccard index is undefined if both bitmaps are empty."]
    pub fn roaring_bitmap_jaccard_index(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> f64;
}
extern "C" {
    #[doc = " Computes the size of the union between two bitmaps."]
    pub fn roaring_bitmap_or_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the difference (andnot) between two bitmaps."]
    pub fn roaring_bitmap_andnot_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the symmetric difference (xor) between two bitmaps."]
    pub fn roaring_bitmap_xor_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_and()`, modifies r1\n r1 == r2 is allowed.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmap."]
    pub fn roaring_bitmap_and_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the union between two bitmaps and returns new bitmap. The caller is\n responsible for memory management."]
    pub fn roaring_bitmap_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_or(), modifies r1.\n TODO: decide whether r1 == r2 ok"]
    pub fn roaring_bitmap_or_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps.\n Caller is responsible for freeing the result.\n See also `roaring_bitmap_or_many_heap()`"]
    pub fn roaring_bitmap_or_many(
        number: usize,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps using a heap. This can sometimes be\n faster than `roaring_bitmap_or_many() which uses a naive algorithm.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_or_many_heap(
        number: u32,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the symmetric difference (xor) between two bitmaps\n and returns new bitmap. The caller is responsible for memory management."]
    pub fn roaring_bitmap_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_xor, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the xor of 'number' bitmaps.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_xor_many(
        number: usize,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the difference (andnot) between two bitmaps and returns new bitmap.\n Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_andnot(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_andnot, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_andnot_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Frees the memory."]
    pub fn roaring_bitmap_free(r: *const roaring_bitmap_t);
}
#[doc = " A bit of context usable with `roaring_bitmap_*_bulk()` functions\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap\n (unless re-initialized to zero), and any modification to a bitmap\n (other than modifications performed with `_bulk()` functions with the context\n passed) will invalidate any contexts associated with that bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_bulk_context_s {
    pub container: *mut ::core::ffi::c_void,
    pub idx: ::core::ffi::c_int,
    pub key: u16,
    pub typecode: u8,
}
#[doc = " A bit of context usable with `roaring_bitmap_*_bulk()` functions\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap\n (unless re-initialized to zero), and any modification to a bitmap\n (other than modifications performed with `_bulk()` functions with the context\n passed) will invalidate any contexts associated with that bitmap."]
pub type roaring_bulk_context_t = roaring_bulk_context_s;
extern "C" {
    #[doc = " Add an item, using context from a previous insert for speed optimization.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same \"key\" (high 16 bits of the value) consecutively."]
    pub fn roaring_bitmap_add_bulk(
        r: *mut roaring_bitmap_t,
        context: *mut roaring_bulk_context_t,
        val: u32,
    );
}
extern "C" {
    #[doc = " Add value n_args from pointer vals, faster than repeatedly calling\n `roaring_bitmap_add()`\n\n In order to exploit this optimization, the caller should attempt to keep\n values with the same \"key\" (high 16 bits of the value) as consecutive\n elements in `vals`"]
    pub fn roaring_bitmap_add_many(r: *mut roaring_bitmap_t, n_args: usize, vals: *const u32);
}
extern "C" {
    #[doc = " Add value x"]
    pub fn roaring_bitmap_add(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Add value x\n Returns true if a new value was added, false if the value already existed."]
    pub fn roaring_bitmap_add_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Add all values in range [min, max]"]
    pub fn roaring_bitmap_add_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Add all values in range [min, max)"]
    pub fn roaring_bitmap_add_range(r: *mut roaring_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Remove value x"]
    pub fn roaring_bitmap_remove(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Remove all values in range [min, max]"]
    pub fn roaring_bitmap_remove_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Remove all values in range [min, max)"]
    pub fn roaring_bitmap_remove_range(r: *mut roaring_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Remove multiple values"]
    pub fn roaring_bitmap_remove_many(r: *mut roaring_bitmap_t, n_args: usize, vals: *const u32);
}
extern "C" {
    #[doc = " Remove value x\n Returns true if a new value was removed, false if the value was not existing."]
    pub fn roaring_bitmap_remove_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Check if value is present"]
    pub fn roaring_bitmap_contains(r: *const roaring_bitmap_t, val: u32) -> bool;
}
extern "C" {
    #[doc = " Check whether a range of values from range_start (included)\n to range_end (excluded) is present"]
    pub fn roaring_bitmap_contains_range(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a range of values from range_start (included)\n to range_end (included) is present"]
    pub fn roaring_bitmap_contains_range_closed(
        r: *const roaring_bitmap_t,
        range_start: u32,
        range_end: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if an items is present, using context from a previous insert or search\n for speed optimization.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same \"key\" (high 16 bits of the value) consecutively."]
    pub fn roaring_bitmap_contains_bulk(
        r: *const roaring_bitmap_t,
        context: *mut roaring_bulk_context_t,
        val: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the cardinality of the bitmap (number of elements)."]
    pub fn roaring_bitmap_get_cardinality(r: *const roaring_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [range_start, range_end)."]
    pub fn roaring_bitmap_range_cardinality(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [range_start, range_end]."]
    pub fn roaring_bitmap_range_cardinality_closed(
        r: *const roaring_bitmap_t,
        range_start: u32,
        range_end: u32,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns true if the bitmap is empty (cardinality is zero)."]
    pub fn roaring_bitmap_is_empty(r: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Empties the bitmap.  It will have no auxiliary allocations (so if the bitmap\n was initialized in client memory via roaring_bitmap_init(), then a call to\n roaring_bitmap_clear() would be enough to \"free\" it)"]
    pub fn roaring_bitmap_clear(r: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Convert the bitmap to a sorted array, output in `ans`.\n\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n\n     ans = malloc(roaring_bitmap_get_cardinality(bitmap) * sizeof(uint32_t));"]
    pub fn roaring_bitmap_to_uint32_array(r: *const roaring_bitmap_t, ans: *mut u32);
}
extern "C" {
    #[doc = " Store the bitmap to a bitset. This can be useful for people\n who need the performance and simplicity of a standard bitset.\n We assume that the input bitset is originally empty (does not\n have any set bit).\n\n   bitset_t * out = bitset_create();\n   // if the bitset has content in it, call \"bitset_clear(out)\"\n   bool success = roaring_bitmap_to_bitset(mybitmap, out);\n   // on failure, success will be false.\n   // You can then query the bitset:\n   bool is_present = bitset_get(out,  10011 );\n   // you must free the memory:\n   bitset_free(out);\n"]
    pub fn roaring_bitmap_to_bitset(r: *const roaring_bitmap_t, bitset: *mut bitset_t) -> bool;
}
extern "C" {
    #[doc = " Convert the bitmap to a sorted array from `offset` by `limit`, output in\n `ans`.\n\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n\n     ans = malloc(roaring_bitmap_get_cardinality(limit) * sizeof(uint32_t));\n\n Return false in case of failure (e.g., insufficient memory)"]
    pub fn roaring_bitmap_range_uint32_array(
        r: *const roaring_bitmap_t,
        offset: usize,
        limit: usize,
        ans: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove run-length encoding even when it is more space efficient.\n Return whether a change was applied."]
    pub fn roaring_bitmap_remove_run_compression(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Convert array and bitmap containers to run containers when it is more\n efficient; also convert from run containers when more space efficient.\n\n Returns true if the result has at least one run container.\n Additional savings might be possible by calling `shrinkToFit()`."]
    pub fn roaring_bitmap_run_optimize(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " If needed, reallocate memory to shrink the memory usage.\n Returns the number of bytes saved."]
    pub fn roaring_bitmap_shrink_to_fit(r: *mut roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Write the bitmap to an output pointer, this output buffer should refer to\n at least `roaring_bitmap_size_in_bytes(r)` allocated bytes.\n\n See `roaring_bitmap_portable_serialize()` if you want a format that's\n compatible with Java and Go implementations.  This format can sometimes be\n more space efficient than the portable form, e.g. when the data is sparse.\n\n Returns how many bytes written, should be `roaring_bitmap_size_in_bytes(r)`.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems.\n\n When serializing data to a file, we recommend that you also use\n checksums so that, at deserialization, you can be confident\n that you are recovering the correct data."]
    pub fn roaring_bitmap_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Use with `roaring_bitmap_serialize()`.\n\n (See `roaring_bitmap_portable_deserialize()` if you want a format that's\n compatible with Java and Go implementations).\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring_bitmap_deserialize(buf: *const ::core::ffi::c_void) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Use with `roaring_bitmap_serialize()`.\n\n (See `roaring_bitmap_portable_deserialize_safe()` if you want a format that's\n compatible with Java and Go implementations).\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems.\n\n The difference with `roaring_bitmap_deserialize()` is that this function\n checks that the input buffer is a valid bitmap.  If the buffer is too small,\n NULL is returned."]
    pub fn roaring_bitmap_deserialize_safe(
        buf: *const ::core::ffi::c_void,
        maxbytes: usize,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap (NOT compatible\n with Java and Go versions)"]
    pub fn roaring_bitmap_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer.\n In case of failure, NULL is returned.\n\n This function is unsafe in the sense that if there is no valid serialized\n bitmap at the pointer, then many bytes could be read, possibly causing a\n buffer overflow.  See also roaring_bitmap_portable_deserialize_safe().\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize(
        buf: *const ::core::ffi::c_char,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer safely (reading up to maxbytes).\n In case of failure, NULL is returned.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n The function itself is safe in the sense that it will not cause buffer\n overflows: it will not read beyond the scope of the provided buffer\n (buf,maxbytes).\n\n However, for correct operations, it is assumed that the bitmap\n read was once serialized from a valid bitmap (i.e., it follows the format\n specification). If you provided an incorrect input (garbage), then the bitmap\n read may not be in a valid state and following operations may not lead to\n sensible results. In particular, the serialized array containers need to be\n in sorted order, and the run containers should be in sorted non-overlapping\n order. This is is guaranteed to happen when serializing an existing bitmap,\n but not for random inputs.\n\n If the source is untrusted, you should call\n roaring_bitmap_internal_validate to check the validity of the\n bitmap prior to using it. Only after calling roaring_bitmap_internal_validate\n is the bitmap considered safe for use.\n\n We also recommend that you use checksums to check that serialized data\n corresponds to the serialized bitmap. The CRoaring library does not provide\n checksumming.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize_safe(
        buf: *const ::core::ffi::c_char,
        maxbytes: usize,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer.\n In case of failure, NULL is returned.\n\n Bitmap returned by this function can be used in all readonly contexts.\n Bitmap must be freed as usual, by calling roaring_bitmap_free().\n Underlying buffer must not be freed or modified while it backs any bitmaps.\n\n The function is unsafe in the following ways:\n 1) It may execute unaligned memory accesses.\n 2) A buffer overflow may occur if buf does not point to a valid serialized\n    bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring_bitmap_portable_deserialize_frozen(
        buf: *const ::core::ffi::c_char,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Check how many bytes would be read (up to maxbytes) at this pointer if there\n is a bitmap, returns zero if there is no valid bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_deserialize_size(
        buf: *const ::core::ffi::c_char,
        maxbytes: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Write a bitmap to a char buffer.  The output buffer should refer to at least\n `roaring_bitmap_portable_size_in_bytes(r)` bytes of allocated memory.\n\n Returns how many bytes were written which should match\n `roaring_bitmap_portable_size_in_bytes(r)`.\n\n This is meant to be compatible with the Java and Go versions:\n https://github.com/RoaringBitmap/RoaringFormatSpec\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems.\n\n When serializing data to a file, we recommend that you also use\n checksums so that, at deserialization, you can be confident\n that you are recovering the correct data."]
    pub fn roaring_bitmap_portable_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns number of bytes required to serialize bitmap using frozen format."]
    pub fn roaring_bitmap_frozen_size_in_bytes(r: *const roaring_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Serializes bitmap using frozen format.\n Buffer size must be at least roaring_bitmap_frozen_size_in_bytes().\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems.\n\n When serializing data to a file, we recommend that you also use\n checksums so that, at deserialization, you can be confident\n that you are recovering the correct data."]
    pub fn roaring_bitmap_frozen_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Creates constant bitmap that is a view of a given buffer.\n Buffer data should have been written by `roaring_bitmap_frozen_serialize()`\n Its beginning must also be aligned by 32 bytes.\n Length must be equal exactly to `roaring_bitmap_frozen_size_in_bytes()`.\n In case of failure, NULL is returned.\n\n Bitmap returned by this function can be used in all readonly contexts.\n Bitmap must be freed as usual, by calling roaring_bitmap_free().\n Underlying buffer must not be freed or modified while it backs any bitmaps.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring_bitmap_frozen_view(
        buf: *const ::core::ffi::c_char,
        length: usize,
    ) -> *const roaring_bitmap_t;
}
extern "C" {
    #[doc = " Iterate over the bitmap elements. The function iterator is called once for\n all the values with ptr (can be NULL) as the second parameter of each call.\n\n `roaring_iterator` is simply a pointer to a function that returns bool\n (true means that the iteration should continue while false means that it\n should stop), and takes (uint32_t,void*) as inputs.\n\n Returns true if the roaring_iterator returned true throughout (so that all\n data points were necessarily visited).\n\n Iteration is ordered: from the smallest to the largest elements."]
    pub fn roaring_iterate(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator,
        ptr: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn roaring_iterate64(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator64,
        high_bits: u64,
        ptr: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the two bitmaps contain the same elements."]
    pub fn roaring_bitmap_equals(r1: *const roaring_bitmap_t, r2: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2."]
    pub fn roaring_bitmap_is_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2, and r2 is strictly\n greater than r1."]
    pub fn roaring_bitmap_is_strict_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Computes the union between two bitmaps and returns new bitmap. The caller is\n responsible for memory management.\n\n The lazy version defers some computations such as the maintenance of the\n cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`\n after executing \"lazy\" computations.\n\n It is safe to repeatedly call roaring_bitmap_lazy_or_inplace on the result.\n\n `bitsetconversion` is a flag which determines whether container-container\n operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Inplace version of roaring_bitmap_lazy_or, modifies r1.\n\n `bitsetconversion` is a flag which determines whether container-container\n operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or_inplace(
        r1: *mut roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    );
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Execute maintenance on a bitmap created from `roaring_bitmap_lazy_or()`\n or modified with `roaring_bitmap_lazy_or_inplace()`."]
    pub fn roaring_bitmap_repair_after_lazy(r1: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the symmetric difference between two bitmaps and returns new bitmap.\n The caller is responsible for memory management.\n\n The lazy version defers some computations such as the maintenance of the\n cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`\n after executing \"lazy\" computations.\n\n It is safe to repeatedly call `roaring_bitmap_lazy_xor_inplace()` on\n the result."]
    pub fn roaring_bitmap_lazy_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)\n\n Inplace version of roaring_bitmap_lazy_xor, modifies r1. r1 != r2"]
    pub fn roaring_bitmap_lazy_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [range_start, range_end).\n The number of negated values is range_end - range_start.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip(
        r1: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [range_start, range_end].\n The number of negated values is range_end - range_start + 1.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip_closed(
        x1: *const roaring_bitmap_t,
        range_start: u32,
        range_end: u32,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " compute (in place) the negation of the roaring bitmap within a specified\n interval: [range_start, range_end). The number of negated values is\n range_end - range_start.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip_inplace(r1: *mut roaring_bitmap_t, range_start: u64, range_end: u64);
}
extern "C" {
    #[doc = " compute (in place) the negation of the roaring bitmap within a specified\n interval: [range_start, range_end]. The number of negated values is\n range_end - range_start + 1.\n Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip_inplace_closed(
        r1: *mut roaring_bitmap_t,
        range_start: u32,
        range_end: u32,
    );
}
extern "C" {
    #[doc = " Selects the element at index 'rank' where the smallest element is at index 0.\n If the size of the roaring bitmap is strictly greater than rank, then this\n function returns true and sets element to the element of given rank.\n Otherwise, it returns false."]
    pub fn roaring_bitmap_select(r: *const roaring_bitmap_t, rank: u32, element: *mut u32) -> bool;
}
extern "C" {
    #[doc = " roaring_bitmap_rank returns the number of integers that are smaller or equal\n to x. Thus if x is the first element, this function will return 1. If\n x is smaller than the smallest element, this function will return 0.\n\n The indexing convention differs between roaring_bitmap_select and\n roaring_bitmap_rank: roaring_bitmap_select refers to the smallest value\n as having index 0, whereas roaring_bitmap_rank returns 1 when ranking\n the smallest value."]
    pub fn roaring_bitmap_rank(r: *const roaring_bitmap_t, x: u32) -> u64;
}
extern "C" {
    #[doc = " roaring_bitmap_rank_many is an `Bulk` version of `roaring_bitmap_rank`\n it puts rank value of each element in `[begin .. end)` to `ans[]`\n\n the values in `[begin .. end)` must be sorted in Ascending order;\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n\n     ans = malloc((end-begin) * sizeof(uint64_t));"]
    pub fn roaring_bitmap_rank_many(
        r: *const roaring_bitmap_t,
        begin: *const u32,
        end: *const u32,
        ans: *mut u64,
    );
}
extern "C" {
    #[doc = " Returns the index of x in the given roaring bitmap.\n If the roaring bitmap doesn't contain x , this function will return -1.\n The difference with rank function is that this function will return -1 when x\n is not the element of roaring bitmap, but the rank function will return a\n non-negative number."]
    pub fn roaring_bitmap_get_index(r: *const roaring_bitmap_t, x: u32) -> i64;
}
extern "C" {
    #[doc = " Returns the smallest value in the set, or UINT32_MAX if the set is empty."]
    pub fn roaring_bitmap_minimum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " Returns the greatest value in the set, or 0 if the set is empty."]
    pub fn roaring_bitmap_maximum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " (For advanced users.)\n\n Collect statistics about the bitmap, see roaring_types.h for\n a description of roaring_statistics_t"]
    pub fn roaring_bitmap_statistics(r: *const roaring_bitmap_t, stat: *mut roaring_statistics_t);
}
extern "C" {
    #[doc = " Perform internal consistency checks. Returns true if the bitmap is\n consistent. It may be useful to call this after deserializing bitmaps from\n untrusted sources. If roaring_bitmap_internal_validate returns true, then the\n bitmap should be consistent and can be trusted not to cause crashes or memory\n corruption.\n\n Note that some operations intentionally leave bitmaps in an inconsistent\n state temporarily, for example, `roaring_bitmap_lazy_*` functions, until\n `roaring_bitmap_repair_after_lazy` is called.\n\n If reason is non-null, it will be set to a string describing the first\n inconsistency found if any."]
    pub fn roaring_bitmap_internal_validate(
        r: *const roaring_bitmap_t,
        reason: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
#[doc = " A struct used to keep iterator state. Users should only access\n `current_value` and `has_value`, the rest of the type should be treated as\n opaque."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_uint32_iterator_s {
    pub parent: *const roaring_bitmap_t,
    pub container: *const ::core::ffi::c_void,
    pub typecode: u8,
    pub container_index: i32,
    pub highbits: u32,
    pub container_it: roaring_container_iterator_t,
    pub current_value: u32,
    pub has_value: bool,
}
#[doc = " A struct used to keep iterator state. Users should only access\n `current_value` and `has_value`, the rest of the type should be treated as\n opaque."]
pub type roaring_uint32_iterator_t = roaring_uint32_iterator_s;
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the values.\n If there is a  value, then this iterator points to the first value and\n `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_iterator_init(r: *const roaring_bitmap_t, newit: *mut roaring_uint32_iterator_t);
}
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the values.\n If there is a value, then this iterator points to the last value and\n `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_iterator_init_last(
        r: *const roaring_bitmap_t,
        newit: *mut roaring_uint32_iterator_t,
    );
}
extern "C" {
    #[doc = " Create an iterator object that can be used to iterate through the values.\n Caller is responsible for calling `roaring_free_iterator()`.\n\n The iterator is initialized (this function calls `roaring_iterator_init()`)\n If there is a value, then this iterator points to the first value and\n `it->has_value` is true.  The value is in `it->current_value`."]
    pub fn roaring_iterator_create(r: *const roaring_bitmap_t) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Advance the iterator. If there is a new value, then `it->has_value` is true.\n The new value is in `it->current_value`. Values are traversed in increasing\n orders. For convenience, returns `it->has_value`.\n\n Once `it->has_value` is false, `roaring_uint32_iterator_advance` should not\n be called on the iterator again. Calling `roaring_uint32_iterator_previous`\n is allowed."]
    pub fn roaring_uint32_iterator_advance(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Decrement the iterator. If there's a new value, then `it->has_value` is true.\n The new value is in `it->current_value`. Values are traversed in decreasing\n order. For convenience, returns `it->has_value`.\n\n Once `it->has_value` is false, `roaring_uint32_iterator_previous` should not\n be called on the iterator again. Calling `roaring_uint32_iterator_advance` is\n allowed."]
    pub fn roaring_uint32_iterator_previous(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Move the iterator to the first value >= `val`. If there is a such a value,\n then `it->has_value` is true. The new value is in `it->current_value`.\n For convenience, returns `it->has_value`."]
    pub fn roaring_uint32_iterator_move_equalorlarger(
        it: *mut roaring_uint32_iterator_t,
        val: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a copy of an iterator.\n Caller must free it."]
    pub fn roaring_uint32_iterator_copy(
        it: *const roaring_uint32_iterator_t,
    ) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Free memory following `roaring_iterator_create()`"]
    pub fn roaring_uint32_iterator_free(it: *mut roaring_uint32_iterator_t);
}
extern "C" {
    pub fn roaring_uint32_iterator_read(
        it: *mut roaring_uint32_iterator_t,
        buf: *mut u32,
        count: u32,
    ) -> u32;
}
pub type roaring_malloc_p =
    ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::core::ffi::c_void>;
pub type roaring_realloc_p = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void,
>;
pub type roaring_calloc_p = ::core::option::Option<
    unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void,
>;
pub type roaring_free_p =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type roaring_aligned_malloc_p = ::core::option::Option<
    unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void,
>;
pub type roaring_aligned_free_p =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_memory_s {
    pub malloc: roaring_malloc_p,
    pub realloc: roaring_realloc_p,
    pub calloc: roaring_calloc_p,
    pub free: roaring_free_p,
    pub aligned_malloc: roaring_aligned_malloc_p,
    pub aligned_free: roaring_aligned_free_p,
}
pub type roaring_memory_t = roaring_memory_s;
extern "C" {
    pub fn roaring_init_memory_hook(memory_hook: roaring_memory_t);
}
extern "C" {
    pub fn roaring_malloc(arg1: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn roaring_realloc(arg1: *mut ::core::ffi::c_void, arg2: usize)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn roaring_calloc(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn roaring_free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn roaring_aligned_malloc(arg1: usize, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn roaring_aligned_free(arg1: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring64_bitmap_s {
    _unused: [u8; 0],
}
pub type roaring64_bitmap_t = roaring64_bitmap_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring64_leaf_s {
    _unused: [u8; 0],
}
pub type roaring64_leaf_t = roaring64_leaf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring64_iterator_s {
    _unused: [u8; 0],
}
pub type roaring64_iterator_t = roaring64_iterator_s;
#[doc = " A bit of context usable with `roaring64_bitmap_*_bulk()` functions.\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap (unless re-initialized to\n zero), and any modification to a bitmap (other than modifications performed\n with `_bulk()` functions with the context passed) will invalidate any\n contexts associated with that bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring64_bulk_context_s {
    pub high_bytes: [u8; 6usize],
    pub leaf: *mut roaring64_leaf_t,
}
#[doc = " A bit of context usable with `roaring64_bitmap_*_bulk()` functions.\n\n Should be initialized with `{0}` (or `memset()` to all zeros).\n Callers should treat it as an opaque type.\n\n A context may only be used with a single bitmap (unless re-initialized to\n zero), and any modification to a bitmap (other than modifications performed\n with `_bulk()` functions with the context passed) will invalidate any\n contexts associated with that bitmap."]
pub type roaring64_bulk_context_t = roaring64_bulk_context_s;
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty).\n Client is responsible for calling `roaring64_bitmap_free()`."]
    pub fn roaring64_bitmap_create() -> *mut roaring64_bitmap_t;
}
extern "C" {
    pub fn roaring64_bitmap_free(r: *mut roaring64_bitmap_t);
}
extern "C" {
    #[doc = " Returns a copy of a bitmap."]
    pub fn roaring64_bitmap_copy(r: *const roaring64_bitmap_t) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Creates a new bitmap of a pointer to N 64-bit integers."]
    pub fn roaring64_bitmap_of_ptr(n_args: usize, vals: *const u64) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Create a new bitmap by moving containers from a 32 bit roaring bitmap.\n\n After calling this function, the original bitmap will be empty, and the\n returned bitmap will contain all the values from the original bitmap."]
    pub fn roaring64_bitmap_move_from_roaring32(
        r: *mut roaring_bitmap_t,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Create a new bitmap containing all the values in [min, max) that are at a\n distance k*step from min."]
    pub fn roaring64_bitmap_from_range(min: u64, max: u64, step: u64) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Adds the provided value to the bitmap."]
    pub fn roaring64_bitmap_add(r: *mut roaring64_bitmap_t, val: u64);
}
extern "C" {
    #[doc = " Adds the provided value to the bitmap.\n Returns true if a new value was added, false if the value already existed."]
    pub fn roaring64_bitmap_add_checked(r: *mut roaring64_bitmap_t, val: u64) -> bool;
}
extern "C" {
    #[doc = " Add an item, using context from a previous insert for faster insertion.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same high 48 bits of the value consecutively."]
    pub fn roaring64_bitmap_add_bulk(
        r: *mut roaring64_bitmap_t,
        context: *mut roaring64_bulk_context_t,
        val: u64,
    );
}
extern "C" {
    #[doc = " Add `n_args` values from `vals`, faster than repeatedly calling\n `roaring64_bitmap_add()`\n\n In order to exploit this optimization, the caller should attempt to keep\n values with the same high 48 bits of the value as consecutive elements in\n `vals`."]
    pub fn roaring64_bitmap_add_many(r: *mut roaring64_bitmap_t, n_args: usize, vals: *const u64);
}
extern "C" {
    #[doc = " Add all values in range [min, max)."]
    pub fn roaring64_bitmap_add_range(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Add all values in range [min, max]."]
    pub fn roaring64_bitmap_add_range_closed(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Removes a value from the bitmap if present."]
    pub fn roaring64_bitmap_remove(r: *mut roaring64_bitmap_t, val: u64);
}
extern "C" {
    #[doc = " Removes a value from the bitmap if present, returns true if the value was\n removed and false if the value was not present."]
    pub fn roaring64_bitmap_remove_checked(r: *mut roaring64_bitmap_t, val: u64) -> bool;
}
extern "C" {
    #[doc = " Remove an item, using context from a previous insert for faster removal.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same high 48 bits of the value consecutively."]
    pub fn roaring64_bitmap_remove_bulk(
        r: *mut roaring64_bitmap_t,
        context: *mut roaring64_bulk_context_t,
        val: u64,
    );
}
extern "C" {
    #[doc = " Remove `n_args` values from `vals`, faster than repeatedly calling\n `roaring64_bitmap_remove()`\n\n In order to exploit this optimization, the caller should attempt to keep\n values with the same high 48 bits of the value as consecutive elements in\n `vals`."]
    pub fn roaring64_bitmap_remove_many(
        r: *mut roaring64_bitmap_t,
        n_args: usize,
        vals: *const u64,
    );
}
extern "C" {
    #[doc = " Remove all values in range [min, max)."]
    pub fn roaring64_bitmap_remove_range(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Remove all values in range [min, max]."]
    pub fn roaring64_bitmap_remove_range_closed(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " Empties the bitmap."]
    pub fn roaring64_bitmap_clear(r: *mut roaring64_bitmap_t);
}
extern "C" {
    #[doc = " Returns true if the provided value is present."]
    pub fn roaring64_bitmap_contains(r: *const roaring64_bitmap_t, val: u64) -> bool;
}
extern "C" {
    #[doc = " Returns true if all values in the range [min, max) are present."]
    pub fn roaring64_bitmap_contains_range(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if an item is present using context from a previous insert or search\n for faster search.\n\n `context` will be used to store information between calls to make bulk\n operations faster. `*context` should be zero-initialized before the first\n call to this function.\n\n Modifying the bitmap in any way (other than `-bulk` suffixed functions)\n will invalidate the stored context, calling this function with a non-zero\n context after doing any modification invokes undefined behavior.\n\n In order to exploit this optimization, the caller should call this function\n with values with the same high 48 bits of the value consecutively."]
    pub fn roaring64_bitmap_contains_bulk(
        r: *const roaring64_bitmap_t,
        context: *mut roaring64_bulk_context_t,
        val: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Selects the element at index 'rank' where the smallest element is at index 0.\n If the size of the bitmap is strictly greater than rank, then this function\n returns true and sets element to the element of given rank. Otherwise, it\n returns false."]
    pub fn roaring64_bitmap_select(
        r: *const roaring64_bitmap_t,
        rank: u64,
        element: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number of integers that are smaller or equal to x. Thus if x is\n the first element, this function will return 1. If x is smaller than the\n smallest element, this function will return 0.\n\n The indexing convention differs between roaring64_bitmap_select and\n roaring64_bitmap_rank: roaring_bitmap64_select refers to the smallest value\n as having index 0, whereas roaring64_bitmap_rank returns 1 when ranking\n the smallest value."]
    pub fn roaring64_bitmap_rank(r: *const roaring64_bitmap_t, val: u64) -> u64;
}
extern "C" {
    #[doc = " Returns true if the given value is in the bitmap, and sets `out_index` to the\n (0-based) index of the value in the bitmap. Returns false if the value is not\n in the bitmap."]
    pub fn roaring64_bitmap_get_index(
        r: *const roaring64_bitmap_t,
        val: u64,
        out_index: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number of values in the bitmap."]
    pub fn roaring64_bitmap_get_cardinality(r: *const roaring64_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [min, max)."]
    pub fn roaring64_bitmap_range_cardinality(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [min, max]"]
    pub fn roaring64_bitmap_range_closed_cardinality(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns true if the bitmap is empty (cardinality is zero)."]
    pub fn roaring64_bitmap_is_empty(r: *const roaring64_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Returns the smallest value in the set, or UINT64_MAX if the set is empty."]
    pub fn roaring64_bitmap_minimum(r: *const roaring64_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns the largest value in the set, or 0 if empty."]
    pub fn roaring64_bitmap_maximum(r: *const roaring64_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns true if the result has at least one run container."]
    pub fn roaring64_bitmap_run_optimize(r: *mut roaring64_bitmap_t) -> bool;
}
extern "C" {
    #[doc = "  (For advanced users.)\n Collect statistics about the bitmap"]
    pub fn roaring64_bitmap_statistics(
        r: *const roaring64_bitmap_t,
        stat: *mut roaring64_statistics_t,
    );
}
extern "C" {
    #[doc = " Perform internal consistency checks.\n\n Returns true if the bitmap is consistent. It may be useful to call this\n after deserializing bitmaps from untrusted sources. If\n roaring64_bitmap_internal_validate returns true, then the bitmap is\n consistent and can be trusted not to cause crashes or memory corruption.\n\n If reason is non-null, it will be set to a string describing the first\n inconsistency found if any."]
    pub fn roaring64_bitmap_internal_validate(
        r: *const roaring64_bitmap_t,
        reason: *mut *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the two bitmaps contain the same elements."]
    pub fn roaring64_bitmap_equals(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2."]
    pub fn roaring64_bitmap_is_subset(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2, and r2 is strictly\n greater than r1."]
    pub fn roaring64_bitmap_is_strict_subset(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Computes the intersection between two bitmaps and returns new bitmap. The\n caller is responsible for free-ing the result.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmaps. You may\n also rely on roaring64_bitmap_and_inplace to avoid creating many temporary\n bitmaps."]
    pub fn roaring64_bitmap_and(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the intersection between two bitmaps."]
    pub fn roaring64_bitmap_and_cardinality(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_and()`, modifies `r1`. `r1` and `r2`\n are allowed to be equal.\n\n Performance hint: if you are computing the intersection between several\n bitmaps, two-by-two, it is best to start with the smallest bitmaps."]
    pub fn roaring64_bitmap_and_inplace(r1: *mut roaring64_bitmap_t, r2: *const roaring64_bitmap_t);
}
extern "C" {
    #[doc = " Check whether two bitmaps intersect."]
    pub fn roaring64_bitmap_intersect(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a bitmap intersects the range [min, max)."]
    pub fn roaring64_bitmap_intersect_with_range(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Computes the Jaccard index between two bitmaps. (Also known as the Tanimoto\n distance, or the Jaccard similarity coefficient)\n\n The Jaccard index is undefined if both bitmaps are empty."]
    pub fn roaring64_bitmap_jaccard_index(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> f64;
}
extern "C" {
    #[doc = " Computes the union between two bitmaps and returns new bitmap. The caller is\n responsible for free-ing the result."]
    pub fn roaring64_bitmap_or(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the union between two bitmaps."]
    pub fn roaring64_bitmap_or_cardinality(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_or(), modifies `r1`."]
    pub fn roaring64_bitmap_or_inplace(r1: *mut roaring64_bitmap_t, r2: *const roaring64_bitmap_t);
}
extern "C" {
    #[doc = " Computes the symmetric difference (xor) between two bitmaps and returns a new\n bitmap. The caller is responsible for free-ing the result."]
    pub fn roaring64_bitmap_xor(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the symmetric difference (xor) between two bitmaps."]
    pub fn roaring64_bitmap_xor_cardinality(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_xor()`, modifies `r1`. `r1` and `r2`\n are not allowed to be equal (that would result in an empty bitmap)."]
    pub fn roaring64_bitmap_xor_inplace(r1: *mut roaring64_bitmap_t, r2: *const roaring64_bitmap_t);
}
extern "C" {
    #[doc = " Computes the difference (andnot) between two bitmaps and returns a new\n bitmap. The caller is responsible for free-ing the result."]
    pub fn roaring64_bitmap_andnot(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the difference (andnot) between two bitmaps."]
    pub fn roaring64_bitmap_andnot_cardinality(
        r1: *const roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_andnot()`, modifies `r1`. `r1` and `r2`\n are not allowed to be equal (that would result in an empty bitmap)."]
    pub fn roaring64_bitmap_andnot_inplace(
        r1: *mut roaring64_bitmap_t,
        r2: *const roaring64_bitmap_t,
    );
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [min, max).\n The number of negated values is `max - min`. Areas outside the range are\n passed through unchanged."]
    pub fn roaring64_bitmap_flip(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [min, max].\n The number of negated values is `max - min + 1`. Areas outside the range are\n passed through unchanged."]
    pub fn roaring64_bitmap_flip_closed(
        r: *const roaring64_bitmap_t,
        min: u64,
        max: u64,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_flip`. Compute the negation of the\n bitmap in the interval [min, max). The number of negated values is `max -\n min`. Areas outside the range are passed through unchanged."]
    pub fn roaring64_bitmap_flip_inplace(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " In-place version of `roaring64_bitmap_flip_closed`. Compute the negation of\n the bitmap in the interval [min, max]. The number of negated values is `max -\n min + 1`. Areas outside the range are passed through unchanged."]
    pub fn roaring64_bitmap_flip_closed_inplace(r: *mut roaring64_bitmap_t, min: u64, max: u64);
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap.\n\n This is meant to be compatible with other languages:\n https://github.com/RoaringBitmap/RoaringFormatSpec#extension-for-64-bit-implementations"]
    pub fn roaring64_bitmap_portable_size_in_bytes(r: *const roaring64_bitmap_t) -> usize;
}
extern "C" {
    #[doc = " Write a bitmap to a buffer. The output buffer should refer to at least\n `roaring64_bitmap_portable_size_in_bytes(r)` bytes of allocated memory.\n\n Returns how many bytes were written, which should match\n `roaring64_bitmap_portable_size_in_bytes(r)`.\n\n This is meant to be compatible with other languages:\n https://github.com/RoaringBitmap/RoaringFormatSpec#extension-for-64-bit-implementations\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems.\n\n When serializing data to a file, we recommend that you also use\n checksums so that, at deserialization, you can be confident\n that you are recovering the correct data."]
    pub fn roaring64_bitmap_portable_serialize(
        r: *const roaring64_bitmap_t,
        buf: *mut ::core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Check how many bytes would be read (up to maxbytes) at this pointer if there\n is a valid bitmap, returns zero if there is no valid bitmap.\n\n This is meant to be compatible with other languages\n https://github.com/RoaringBitmap/RoaringFormatSpec#extension-for-64-bit-implementations"]
    pub fn roaring64_bitmap_portable_deserialize_size(
        buf: *const ::core::ffi::c_char,
        maxbytes: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Read a bitmap from a serialized buffer (reading up to maxbytes).\n In case of failure, NULL is returned.\n\n This is meant to be compatible with other languages\n https://github.com/RoaringBitmap/RoaringFormatSpec#extension-for-64-bit-implementations\n\n The function itself is safe in the sense that it will not cause buffer\n overflows: it will not read beyond the scope of the provided buffer\n (buf,maxbytes).\n\n However, for correct operations, it is assumed that the bitmap\n read was once serialized from a valid bitmap (i.e., it follows the format\n specification). If you provided an incorrect input (garbage), then the bitmap\n read may not be in a valid state and following operations may not lead to\n sensible results. In particular, the serialized array containers need to be\n in sorted order, and the run containers should be in sorted non-overlapping\n order. This is is guaranteed to happen when serializing an existing bitmap,\n but not for random inputs.\n\n If the source is untrusted, you should call\n roaring64_bitmap_internal_validate to check the validity of the\n bitmap prior to using it. Only after calling\n roaring64_bitmap_internal_validate is the bitmap considered safe for use.\n\n We also recommend that you use checksums to check that serialized data\n corresponds to the serialized bitmap. The CRoaring library does not provide\n checksumming.\n\n This function is endian-sensitive. If you have a big-endian system (e.g., a\n mainframe IBM s390x), the data format is going to be big-endian and not\n compatible with little-endian systems."]
    pub fn roaring64_bitmap_portable_deserialize_safe(
        buf: *const ::core::ffi::c_char,
        maxbytes: usize,
    ) -> *mut roaring64_bitmap_t;
}
extern "C" {
    #[doc = " Iterate over the bitmap elements. The function `iterator` is called once for\n all the values with `ptr` (can be NULL) as the second parameter of each call.\n\n `roaring_iterator64` is simply a pointer to a function that returns a bool\n and takes `(uint64_t, void*)` as inputs. True means that the iteration should\n continue, while false means that it should stop.\n\n Returns true if the `roaring64_iterator` returned true throughout (so that\n all data points were necessarily visited).\n\n Iteration is ordered from the smallest to the largest elements."]
    pub fn roaring64_bitmap_iterate(
        r: *const roaring64_bitmap_t,
        iterator: roaring_iterator64,
        ptr: *mut ::core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Convert the bitmap to a sorted array `out`.\n\n Caller is responsible to ensure that there is enough memory allocated, e.g.\n ```\n out = malloc(roaring64_bitmap_get_cardinality(bitmap) * sizeof(uint64_t));\n ```"]
    pub fn roaring64_bitmap_to_uint64_array(r: *const roaring64_bitmap_t, out: *mut u64);
}
extern "C" {
    #[doc = " Create an iterator object that can be used to iterate through the values.\n Caller is responsible for calling `roaring64_iterator_free()`.\n\n The iterator is initialized. If there is a value, then this iterator points\n to the first value and `roaring64_iterator_has_value()` returns true. The\n value can be retrieved with `roaring64_iterator_value()`."]
    pub fn roaring64_iterator_create(r: *const roaring64_bitmap_t) -> *mut roaring64_iterator_t;
}
extern "C" {
    #[doc = " Create an iterator object that can be used to iterate through the values.\n Caller is responsible for calling `roaring64_iterator_free()`.\n\n The iterator is initialized. If there is a value, then this iterator points\n to the last value and `roaring64_iterator_has_value()` returns true. The\n value can be retrieved with `roaring64_iterator_value()`."]
    pub fn roaring64_iterator_create_last(
        r: *const roaring64_bitmap_t,
    ) -> *mut roaring64_iterator_t;
}
extern "C" {
    #[doc = " Re-initializes an existing iterator. Functionally the same as\n `roaring64_iterator_create` without a allocation."]
    pub fn roaring64_iterator_reinit(r: *const roaring64_bitmap_t, it: *mut roaring64_iterator_t);
}
extern "C" {
    #[doc = " Re-initializes an existing iterator. Functionally the same as\n `roaring64_iterator_create_last` without a allocation."]
    pub fn roaring64_iterator_reinit_last(
        r: *const roaring64_bitmap_t,
        it: *mut roaring64_iterator_t,
    );
}
extern "C" {
    #[doc = " Creates a copy of the iterator. Caller is responsible for calling\n `roaring64_iterator_free()` on the resulting iterator."]
    pub fn roaring64_iterator_copy(it: *const roaring64_iterator_t) -> *mut roaring64_iterator_t;
}
extern "C" {
    #[doc = " Free the iterator."]
    pub fn roaring64_iterator_free(it: *mut roaring64_iterator_t);
}
extern "C" {
    #[doc = " Returns true if the iterator currently points to a value. If so, calling\n `roaring64_iterator_value()` returns the value."]
    pub fn roaring64_iterator_has_value(it: *const roaring64_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Returns the value the iterator currently points to. Should only be called if\n `roaring64_iterator_has_value()` returns true."]
    pub fn roaring64_iterator_value(it: *const roaring64_iterator_t) -> u64;
}
extern "C" {
    #[doc = " Advance the iterator. If there is a new value, then\n `roaring64_iterator_has_value()` returns true. Values are traversed in\n increasing order. For convenience, returns the result of\n `roaring64_iterator_has_value()`.\n\n Once this returns false, `roaring64_iterator_advance` should not be called on\n the iterator again. Calling `roaring64_iterator_previous` is allowed."]
    pub fn roaring64_iterator_advance(it: *mut roaring64_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Decrement the iterator. If there is a new value, then\n `roaring64_iterator_has_value()` returns true. Values are traversed in\n decreasing order. For convenience, returns the result of\n `roaring64_iterator_has_value()`.\n\n Once this returns false, `roaring64_iterator_previous` should not be called\n on the iterator again. Calling `roaring64_iterator_advance` is allowed."]
    pub fn roaring64_iterator_previous(it: *mut roaring64_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Move the iterator to the first value greater than or equal to `val`, if it\n exists at or after the current position of the iterator. If there is a new\n value, then `roaring64_iterator_has_value()` returns true. Values are\n traversed in increasing order. For convenience, returns the result of\n `roaring64_iterator_has_value()`."]
    pub fn roaring64_iterator_move_equalorlarger(it: *mut roaring64_iterator_t, val: u64) -> bool;
}
extern "C" {
    #[doc = " Reads up to `count` values from the iterator into the given `buf`. Returns\n the number of elements read. The number of elements read can be smaller than\n `count`, which means that there are no more elements in the bitmap.\n\n This function can be used together with other iterator functions."]
    pub fn roaring64_iterator_read(it: *mut roaring64_iterator_t, buf: *mut u64, count: u64)
        -> u64;
}
